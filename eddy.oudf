void exact(dfloat *uu, dfloat *vv, dfloat *ww, dfloat xx, dfloat yy, dfloat zz, dfloat time, dfloat visc)
{
  const dfloat a[10] = {-.2, -.2, .25, 0.0, 0, 0, 0, 0, 0, 0};
  const dfloat cpsi[10] = {0, 5, 3, 4, 0, 0, 0, 0, 0, 0};

  const dfloat aa = cpsi[1] * cpsi[1];
  const dfloat arg = -visc * time * aa; // domain is [0:2pi]
  const dfloat e = exp(arg);

  const dfloat x = xx - p_U0 * time;
  const dfloat y = yy - p_V0 * time;
  const dfloat z = 0.0;

  const dfloat sx = sin(cpsi[1] * x);
  const dfloat cx = cos(cpsi[1] * x);
  const dfloat sy = sin(cpsi[1] * y);
  const dfloat cy = cos(cpsi[1] * y);
  dfloat u = a[0] * cpsi[1] * cy;
  dfloat v = a[1] * cpsi[1] * sx;

  for (int k = 2; k <= 5; ++k) {

    const dfloat s1x = sin(cpsi[0 + 2 * (k - 1)] * x);
    const dfloat c1x = cos(cpsi[0 + 2 * (k - 1)] * x);
    const dfloat s2x = sin(cpsi[1 + 2 * (k - 1)] * x);
    const dfloat c2x = cos(cpsi[1 + 2 * (k - 1)] * x);

    const dfloat s1y = sin(cpsi[0 + 2 * (k - 1)] * y);
    const dfloat c1y = cos(cpsi[0 + 2 * (k - 1)] * y);
    const dfloat s2y = sin(cpsi[1 + 2 * (k - 1)] * y);
    const dfloat c2y = cos(cpsi[1 + 2 * (k - 1)] * y);

    const dfloat c1 = cpsi[0 + 2 * (k - 1)];
    const dfloat c2 = cpsi[1 + 2 * (k - 1)];

    if (k == 2) {
      u = u + a[0 + 2 * (k - 1)] * s1x * c2y * c2;
      v = v - a[0 + 2 * (k - 1)] * c1x * s2y * c1;
      u = u - a[1 + 2 * (k - 1)] * s2x * c1y * c1;
      v = v + a[1 + 2 * (k - 1)] * c2x * s1y * c2;
    }

    if (k == 3) {
      u = u - a[0 + 2 * (k - 1)] * s1x * c2y * c2;
      v = v + a[0 + 2 * (k - 1)] * c1x * s2y * c1;
      u = u - a[1 + 2 * (k - 1)] * c2x * c1y * c1;
      v = v - a[1 + 2 * (k - 1)] * s2x * s1y * c2;
    }

    if (k == 4) {
      u = u + a[0 + 2 * (k - 1)] * c1x * c2y * c2;
      v = v + a[0 + 2 * (k - 1)] * s1x * s2y * c1;
      u = u + a[1 + 2 * (k - 1)] * c2x * c1y * c1;
      v = v + a[1 + 2 * (k - 1)] * s2x * s1y * c2;
    }

    if (k == 5) {
      u = u - a[0 + 2 * (k - 1)] * s1x * c2y * c2;
      v = v + a[0 + 2 * (k - 1)] * c1x * s2y * c1;
      u = u - a[1 + 2 * (k - 1)] * s2x * c1y * c1;
      v = v + a[1 + 2 * (k - 1)] * c2x * s1y * c2;
    }
  }
  (*uu) = u * e + p_U0;
  (*vv) = v * e + p_V0;
  (*ww) = 0.0;
}

void exactP(dfloat *pp, dfloat xx, dfloat yy, dfloat zz, dfloat time, dfloat visc)
{
  const dfloat e = exp(-50*time*visc);

  const dfloat x = xx - p_U0*time;
  const dfloat y = yy - p_V0*time;

  (*pp) = (1.0/64.0)*e*(16*cos(6*x) + 8*cos(8*x-4*y)
     - 32*cos(2*(x-2*y)) + 9*cos(8*y) - 8*cos(4*(2*x+y))
     + 32*cos(2*(x+2*y)) - 4*sin(3*(x-3*y)) + 32*sin(5*(x-y))
     + 36*sin(3*x-y) - 32*sin(5*(x+y)) + 36*sin(3*x+y)
     - 4*sin(3*(x+3*y)));
}

@kernel void exactUVWP(const dlong Ntotal,
                      const dlong offset,
                      const dfloat time,
                      @ restrict const dfloat *X,
                      @ restrict const dfloat *Y,
                      @ restrict const dfloat *Z,
                      @ restrict dfloat *U,
                      @ restrict dfloat *P)
{
  for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
    dfloat u, v, w, p;
    const dfloat x = X[n];
    const dfloat y = Y[n];
    const dfloat z = Z[n];
    exact(&u, &v, &w, x, y, z, time, p_visc);
    exactP(&p, x, y, z, time, p_visc);
    U[n + 0 * offset] = u;
    U[n + 1 * offset] = v;
    U[n + 2 * offset] = w;
    P[n] = p;
  }
}

@kernel void userMeshVelocity(const dlong Ntotal,
                              const dlong offset,
                              @ restrict const dfloat *x,
                              @ restrict const dfloat *y,
                              @ restrict const dfloat *z,
                              @ restrict dfloat *W)
{
  for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
    const dfloat xc = (x[n] - p_pi);
    const dfloat yc = (y[n] - p_pi);
    const dfloat rc = sqrt(xc * xc + yc * yc);
    const dfloat thv = atan2(yc, xc);
    W[n + 0 * offset] = p_omega * rc * sin(thv);
    W[n + 1 * offset] = -p_omega * rc * cos(thv);
    W[n + 2 * offset] = 0.0;
  }
}

@kernel void dpdx(const dlong Nelements,
                                 @ restrict const dfloat *vgeo,
                                 @ restrict const dfloat *invLMM,
                                 @ restrict const dfloat *D,
                                 @ restrict const dfloat *P,
                                 @ restrict dfloat *dp)
{
  for (dlong e = 0; e < Nelements; e++; @outer(0)) { // for all elements
    @shared dfloat s_P[p_Nq][p_Nq];
    @exclusive dfloat s_Ploc[p_Nq];
    @shared dfloat s_D[p_Nq][p_Nq];

#ifdef smXX
#pragma unroll p_Nq
#endif
    for (int k = 0; k < p_Nq; ++k) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong id = e * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          s_P[j][i] = P[id];

          if (k == 0)
            s_D[j][i] = D[j * p_Nq + i];
          if (k == 0) {
#pragma unroll p_Nq
            for (int l = 0; l < p_Nq; ++l) {
              const dlong other_id = e * p_Np + l * p_Nq * p_Nq + j * p_Nq + i;
              s_Ploc[l] = P[other_id];
            }
          }
        }
      }

      // Make sure all node data is loaded into @shared
      @barrier();
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong gid = e * p_Np * p_Nvgeo + k * p_Nq * p_Nq + j * p_Nq + i;
          const dlong id = e * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          const dfloat drdx = vgeo[gid + p_RXID * p_Np];
          const dfloat dsdx = vgeo[gid + p_SXID * p_Np];
          const dfloat dtdx = vgeo[gid + p_TXID * p_Np];
          const dfloat JW = vgeo[gid + p_JWID * p_Np];
          const dfloat imm = invLMM[id];

          // compute 'r' and 's' derivatives of (q_m) at node n
          dfloat dpdr = 0.f, dpds = 0.f, dpdt = 0.f;

#pragma unroll p_Nq
          for (int n = 0; n < p_Nq; ++n) {
            const dfloat Dr = s_D[i][n];
            const dfloat Ds = s_D[j][n];
            const dfloat Dt = s_D[k][n];

            dpdr += Dr * s_P[j][n];
            dpds += Ds * s_P[n][i];
            dpdt += Dt * s_Ploc[n];
          }

          dp[id] = -imm * JW * (drdx * dpdr + dsdx * dpds + dtdx * dpdt);
        }
      }
      @barrier();
    } // k-loop
  }
}
